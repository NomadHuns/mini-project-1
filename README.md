# 구인구직 사이트 프로젝트

## 기술스택
- JDK 11
- Springboot 2.7.8
- MyBatis
- 테스트 h2 디비
- JSP
- Tomcat Jasper
- JSTL
- Redis

## 모델링
### 1단계 (완료)
- User
- Company
- Employee
- Board
### 2단계 (완료)
- Apply
- Tech
- Resume
### 3단계 (완료)
- Love

## 기능정리
### 1단계 (완료)
- [x]  1단계 테이블 기본적인 CRUD 쿼리 생성
- [x]  기업로그인
- [x]  기업회원가입
- [x]  기업회원정보수정
- [x]  일반회원로그인
- [x]  일반회원가입
- [x]  일반회원정보수정
- [x]  로그아웃
- [x]  채용공고 목록보기
- [x]  채용공고 상세보기
- [x]  구직자 목록 페이지
- [x]  구직자 상세 페이지
- [x]  자소서 쓰기
- [x]  채용공고 쓰기
- [x]  채용공고 수정
### 2단계 (완료)
- [x]  내가 작성한채용 공고 목록 이동 board 3
- [x]  지원자 테이블 생성 apply 1
- [x]  보유 기술 테이블 생성 tech 1
- [x]  채용공고 지원하기 apply 1
- [x]  채용공고 지원자 목록 apply 1
- [x]  구직자 목록 정렬하기(보유 기술이 유사한 순으로 정렬 기능 추가) user 2
- [x]  채용공고 목록 정렬하기(보유 기술이 유사한 순으로 정렬 기능 추가) board 3
- [x]  지원하지 않은 구직자 추천 board 3
- [x]  프로필 사진 변경 user, company 2 3
- [x]  아이디 중복 체크(서버에서도 체크) user, company 2 3
- [x]  비밀번호 확인 user, company 1
- [x]  이력서 테이블 생성
### 3단계 (완료)
- [x]  이력서 목록 페이지
- [x]  자신의 이력서 관리 기능
- [x]  채용 공고 지원시 이력서 선택 제출
- [x]  페이징 처리
- [x]  구직자 구독 기능
- [x]  공고 구독 기능
- [x]  비밀번호 SHA-256을 사용하여 해시화
### 4단계
- [x]  공고 지원 남은 날짜 표시
- [x]  AOP 사용
- [x]  Redis 사용

# 주요 시연
## 회원가입
![회원가입1](https://user-images.githubusercontent.com/118786401/232196774-ce324eb5-a4ad-4ccb-9625-7efee63358be.gif)

## 로그인
![로그인](https://user-images.githubusercontent.com/118786401/232635843-3aa73e3d-7f1d-496e-bf1a-eaa79a8b8829.gif)

## 정보 수정
![정보-수정](https://user-images.githubusercontent.com/118786401/232636464-ffc9660d-5867-4878-b1bb-5f19956329ef.gif)

## 공고 등록
![공고등록](https://user-images.githubusercontent.com/118786401/232636481-0759ccc8-5389-406d-a1ca-c0452307b979.gif)

## 공고 수정
![공고수정](https://user-images.githubusercontent.com/118786401/232636500-de46a6a7-46e5-4528-9370-5c6357096682.gif)

## 합/불합 처리
![합불합처리](https://user-images.githubusercontent.com/118786401/232636507-b8b4366b-04b3-4b1d-89f3-3d352f271c16.gif)

## 이력서 수정
![이력서수정](https://user-images.githubusercontent.com/118786401/232636544-794341f5-ec36-44f5-9945-2702d10704db.gif)

## 북마크 기능
![북마크기능](https://user-images.githubusercontent.com/118786401/232636566-eba7e6a0-8d4b-47bd-b8c9-041fe1bee583.gif)

## 지원 신청

# 발표 자료

![page1](https://user-images.githubusercontent.com/118786401/232197082-f4d0cd48-1ec2-4a8a-8b46-49896aaa70ef.png)
![page2](https://user-images.githubusercontent.com/118786401/232197085-b923576e-0314-46b1-8615-1d8a3028deb9.png)
![page3](https://user-images.githubusercontent.com/118786401/232197087-f68e0fcb-2422-4aab-8025-814fb88a42c0.png)
저희는 이러한 개발 프로그램들을 사용하였습니다.

통합 개발 환경 프로그램으로서 비주얼 스튜디오 코드로 코드를 작성하였고,

사용된 주요 언어는 Java입니다.

뷰의 그림들은 html, css와 css 프레임 워크인 bootstrap을 사용하였습니다.

뷰에서 움직이는 그림과 ajax 통신은 javascipt와 jquery를 이용하였습니다.

뷰 컴포넌트는 jsp로 구성하였습니다.

DB는 테스트 DB로서 H2 데이터베이스를 사용하였고 스프링에서 제공하는 http세션

대신 Redis를 사용하였습니다.

서버 프레임 워크로 스프링을 사용하고,

DB에 접근하기 위한 기술 스택으로 마이바티스를 사용하였습니다.

버전 관리는 깃과 깃허브를 사용하였습니다.

![page4](https://user-images.githubusercontent.com/118786401/232197088-98bed8de-d63a-4f6f-a682-f1afe2e6d8f6.png)
기본적으로 클래스명은 대문자로 시작하여 이어지는 단어의 시작이 대문자인 파스칼 표기법을 사용하였고,

반복되어 사용되는 단어를 변하는 단어 뒤에 붙여 사용하기로 하였습니다.

변수명은 카멜 표기법을 사용하기로 하였고,

주어진 변수의 데이터가 어디에서 받아오는지 구분하기 위해,

DB에서 얻어온 데이터를 저장하는 변수명은 PS를 붙이고,

리스트 형태로 저장된 변수는 변수명 뒤에 List를 붙여 구분하였습니다.

또한 Dto로 값을 저장하는 경우 변수명 뒤에 Dto를 붙이도록 약속하였습니다.

Redis에 저장될 유저 정보같은 경우는 principal로 통일하였습니다.

패키지명은 소문자로만 작성하였고,

자바 서버 페이지 파일은 카멜 표기법을 따랐습니다.

![page5](https://user-images.githubusercontent.com/118786401/232197089-170eb0cb-7c91-4e4d-8b38-3da644c60e5b.png)
메소드명은 카멜표기법으로 작성하였습니다.

만약 동사와 명사가 같이 사용될 때에는 동사가 앞으로 오도록 구분하였습니다.

메소드 명이 너무 길어져 코드는 난독성을 저해할 수 있다고 판단해 최대 글자를 설정하였습니다.

컨트롤러에서 사용되는 매핑 메소드들은 최대한 URL과 일치하도록 사용하였습니다.

다만 메소드명을 작성할 때 이부분에서 문제가 있었기 때문에, 차후에 진행할 프로젝트에는 다른 방식을 사용할 예정입니다.

서비스에서는 Repository의 메소드명와 비슷하게 가져가도록 설정하였습니다.

리포지토리의 메소드명 또한 비슷한 방식으로 작명하였습니다.

저희는 MyBatis에서 지원하는 객체안의 필드를 자동으로 바인딩 해주는 기술을 사용하기 위하여,

Param을 사용하지 않는 방식으로 진행하였습니다.

의존성 주입은 @AutoWired를 사용하였습니다.

![page6](https://user-images.githubusercontent.com/118786401/232197094-91b5b530-a735-4300-953e-696a23a36348.png)
테스트에서 사용될 클래스명은 기존에 존재하는 테스트 타겟 클래스명 뒤에 테스트를 붙이는 방식으로 작명하였습니다.

그 안에 들어가는 메소드명 또한 타겟 메소드명 뒤에 언더스코어 테스트를 붙여 사용하였습니다.

![page7](https://user-images.githubusercontent.com/118786401/232197095-59ada3af-7181-4f0b-8850-09e572557325.png)
저희는 git과 github를 사용하였고, 기능별로 각각의 브랜치 토픽을 만들어 dev에 Merge(머지)하는 방식으로 작업하였습니다.

작업할 때에는 git merge 충돌을 방지하기 위해 각 작업할 도메인별로 묶어서 작업을 실시하였습니다.

예를 들면 한 명이 board 패키지에 있는 파일을 작업하고, 다른 한 명은 resume 패키지 작업을 하는 방식으로 진행하였습니다.

이와 같이 작업하니 코드가 덧씌워지거나 혹은 충돌이 일어나는 일은 거의 없었습니다.

다만 후반부 작업에서 같이 작업하는 영역이 겹치는 경우가 많이 후반부 작업에서 조금 애를 먹었습니다.

테이블이 수정되는 등 대규모로 변화가 필요할 때에는 dev 브랜치를 새로 만들어 한 명이 작업하고 한 번에 pull 받는 형식으로 하였습니다.

![page88](https://user-images.githubusercontent.com/118786401/232197120-ebd87422-9e8a-47c7-8a2d-34b6e9fa319f.png)
MVC 패턴에 사용된 기술 입니다.

뷰의 그림들은 html, css와 css 프레임 워크인 bootstrap을 사용하였습니다.

bootstrap을 사용한 이유는 뷰의 그림을 그릴때 다같이 그림을 그리는 방식을 사용하였기에

패딩이나 양 옆간의 간격을 통일하는 작업이 필요한데, 작업할 당시에 bootstrap의 클래스를 미리 정하고 작업했기 때문에 작업 후에 태그의 클래스를 수정한다 거나 하는 일은 피하도
록 설계하였습니다.

ajax 통신은 javascript와 jquery를 사용하였습니다.

뷰 컴포넌트는 jsp로 구성하였습니다.

또한 데이터를 뿌릴때 jstl을 사용하여 뿌렸기 때문에 기존의 jsp의 문제점인 뷰 코드의 지저분함을 어느정도 해결하고자 노력하였습니다.

DB는 

테스트 DB로서 H2 데이터베이스를 사용하였습니다.

테스트할 때 서버를 재 실행할 때마다 데이터값이 초기화 되기때문에 더미데이터를 관리하기 용의하였습니다.

스프링에서 제공하는 http세션 대신 Redis를 사용하였습니다.

서버 프레임 워크로 스프링을 사용하였습니다.

스프링의 장점은 MVC 구조를 편리하게 구현할 수 있기 때문에 유지 보수에 용이합니다.

DB에 접근하기 위한 기술 스택으로 마이바티스를 사용하였습니다.

xml파일로서 쿼리문들을 따로 관리하기 때문에 후에 보수작업이 있을 경우 쿼리문 수정이 용이하기 때문에 사용하였습니다.

![page9](https://user-images.githubusercontent.com/118786401/232197096-efb445f3-3bb7-4b4e-b4eb-392babd35fa3.png)
먼저 유저테이블에대해 설명드리겠습니다.

일단 저희는 구직자와 기업 유저의 공통된 칼럼을 유저테이블에 통합하여 저장하였습니다.

이와같이 설계할 경우 로그인 기능구현을 유저 테이블의 칼럼을 비교하여 가져오고

아래에 있는 롤 칼럼을 비교하는 식으로 기업인지 구직자인지 구분하였습니다.

여기 컴패니테이블을 보시면 유저아이디를 포린키로 가지고 회사에대한 칼럼들이 들어있습니다.

이와 마찬가지로 임플로이 테이블또란 유저아이디를 포린키로 구직자의 정보들을 갖고있습니다.

그다음 보드테이블입니다.

어떠한 유저가 작성하였는지 유저아이디를 포린키로 갖고있으며,

나머지 칼럼들은 작성글에대한 정보를 갖고있습니다.

보드아이디를 포린키로 갖고있는 테이블이 총 세개인데,

좋아요 테이블과 지원테이블 테크테이블이 있겠습니다.

스킬테이블은 보시면 스킬코드의 번호에 따른 이름을 저장한 테이블로

다른 테크테이블에 조인하여 결과값을 문자형태로 갖고오기 위한 데이터테이블입니다.

구직자테이블에서 이력서 테이블이 있는데, 하나의 유저가 여러 이력서를 작성, 관리할 수 있도록 따로 만들었습니다.

![page10](https://user-images.githubusercontent.com/118786401/232197097-2133f96c-bf06-4366-adb6-8432c3554505.png)
일단 컨트롤러는 세션의 값만 비교하여 권한을 확인할 수 있도록 하였고,

서비스는 리파지토리에 접근하여 DB에서 데이터를 가져와 권한을 확인할 수 있도록 하였습니다.

또한 트랜젝션 관리를 위한 어노테이션을 추가하여 도중에 서버 오류가 발생할 경우 데이터를 수정하지 않도록 롤백/ 커밋 시스템을 구축하였습니다.

![page11](https://user-images.githubusercontent.com/118786401/232197099-13e2ec3f-bd1e-4d3c-abab-27c0c9fda90f.png)
ResponsDto는 state를 사용하여 성공 실패여부를 프론트에 전달하도록 하였고,

뒤에 msg 필드에 자세한 내용을 적을 수 있도록 하였습니다.

그리고 조회의 경우 오브젝트 타입의 필드인 data를 사용하여 데이터를 넘길수 있도록 설계하였습니다.

만약 rest한 서버를 구축할 경우 코드에 대한 보완이 필요해 보이며, 이는 후에 추가하도록 하겠습니다.

예외 처리 같은 경우에는 먼저 일반 컨트롤러 예외처리문을 보여드리겠습니다.

필드로 HTTP상태코드의 값을 저장하는 status와 예외 처리이후 이동시킬 페이지를 저장하는 location 필드를 생성하여 사용하였습니다.

생성자는 오버로딩을 사용하였습니다.

그래서 예외 핸들러에서 예외를 처리할 때 해당 예외 객체에 로케이션 필드가 Null이면 history.back()을 사용하고, 로케이션 값이 Null이아니라면 해당 url 요청을 하도록 처리하였습니다.

![page12](https://user-images.githubusercontent.com/118786401/232197101-2f94e77e-8c92-4984-bcac-c7d39d62bdfc.png)
먼저 AOP기술입니다. 먼저 AOP란 관점 지향 프로그래밍으로,

로직을 핵심적인 관점, 부가적인 관점으로 나누어서 모듈화하는 것을 의미합니다.

핵심적인 로직이라함은 예를들면 insert를 실행하는 메소드라면 insert 코드가 핵심점인 기능일 것이고,

부가적인 로직은 세션에서 값을 불러와서 권한을 확인 하는 작업등이 있겠습니다.

일단 로직은 구현하기 위해 필요한 라이브러리를 빌드에 추가하였습니다.

위에 있는 라이브러리가 스프링 부트에서 간편하게 AOP를 사용할 수 있도록 하는 라이브러리입니다.

그 다음으로 저는 커스텀 어노테이션을 만들어 AOP를 구현하였습니다.

커스텀 어노테이션에 메타 어노테이션을 추가하여 어노테이션이 붙을 타겟을 지정하고, 생명 주기를 결정하였습니다.

그 이후에 AOP로 사용할 어노테이션을 관리할 핸들러를 구현하였습니다.

먼저 해당 핸들러를 빈에 등록하여 컨테이너에 띄우기 위하여 컴포넌트 어노테이션을 사용하고, 위에 있는 라이브러리에서 지원하는 어노테이션인 @Aspect를 사용하였습니다.

해당 라이브러리에서 AOP관리를 위한 클래스에서 사용하는 어노테이션입니다.

또한 @Pointcut 어노테이션을 사용하여 어떠한 어노테이션일 실행될 때 호출할 메소드를 설정하고,

@Before 어노테이션을 사용하여 위의 해당 메소드가 호출되기 전에 선제적으로 실행할 코드를 작성하였습니다.

코드를 보시면 해당 어노테이션이 실행될 때 컴패니체크 메소드가 호출되고 그 전에 아래 메소드가 진행됩니다.

저희는 해당 어노테이션이 붙은 메소드가 실행되기 전에 세션값을 비교하는 메소드를 구현하였습니다.

![page13](https://user-images.githubusercontent.com/118786401/232197102-927a8e8f-a598-443b-8d74-3d1673c5eecb.png)
다음 특이 기술은 레디스 입니다.

저희는 스프링 부트에서 제공하는 레디스 라이브러리를 사용하였습니다.

해당 라이브러리에서 제공하는 RedisTemplate에 세션에 저장할 객체를 json타입으로 파싱하여 세션에 저장하고,

세션으로부터 받은 json 타입값을 오브젝트로 변환하여 가져올 수 있도록 하는 RedisService 클래스를 따로 생성하여 사용하였습니다.

![page14](https://user-images.githubusercontent.com/118786401/232197104-1b5ebe75-d83a-4786-9dfd-54a489f060b1.png)
그래서 AOP를 적용한 뒤에 레디스 작업을 했기 때문에 각각의 모든 메소드를 확인하며 수정하지 않아도 되었습니다.

aop핸들러만 수정하면 되므로 금방 수정할 수 있었습니다.

공통 처리를 묶어서 사용할 경우 유지/보수 작업에서 이점이 있다는 것을 깨달았습니다.

![page15](https://user-images.githubusercontent.com/118786401/232197105-2a6c32f6-2376-446c-9b52-061c7f23f1bc.png)

![page16](https://user-images.githubusercontent.com/118786401/232197108-176be1d0-02d5-4912-a856-58c4dda34ee7.png)
![page17](https://user-images.githubusercontent.com/118786401/232197110-2eb1d999-c191-418c-961d-dcc751e155e2.png)
![page18](https://user-images.githubusercontent.com/118786401/232197136-ed6702e4-d4fa-4c09-b2b8-58d850e018f7.png)
![page19](https://user-images.githubusercontent.com/118786401/232197142-10bbca8b-2fa0-4594-bf23-7da933fd6205.png)
기존의 테스트 코드와 다른점은 레디스 서비스를 가져와서 세션에 목세션에 저장하는 코드만 수정되었습니다.

![page20](https://user-images.githubusercontent.com/118786401/232197143-dcb81dcc-0ebf-4a6f-9334-d97162693a38.png)
그리고 회원 정보를 업데이트할 때 MultipartForm타입을 어떻게 테스트 할지가 문제였는데,

일단 테스트코드에서 Mock 파일을 보내는 방법을 모르기도 하였고,

또한 Mockmvc perform에 어떤 메소드를 써야할지 고민이 되었습니다.

결국 찾아낸 방법이 multipart 메소드인데, 앞에 url이 들어가고

미리 만들어둔 가짜 파일을 집어넣고 나머지 form-url 타입으로 들어가는 변수들은 param 메소드로 집어넣었습니다.

결론적으로 테스트는 정상적으로 작동되었습니다.

![page21](https://user-images.githubusercontent.com/118786401/232197145-91f2962b-3ead-4135-8ab7-2a4aa5c9010a.png)
![page22](https://user-images.githubusercontent.com/118786401/232197147-a7f34128-583d-4636-8c8a-e12f766fad1b.png)
![page23](https://user-images.githubusercontent.com/118786401/232197148-0eb3d95b-1399-4ecd-928e-b7306ec2f259.png)
다음은 레파지토리 테스트입니다.

테스트를 위해서 MyBatis 테스트 라이브러리를 빌드에 추가하였습니다.

해당 라이브러리에서 제공하는 @마이바티스 어노테이션을 사용하였습니다.

해당 어노테이션은 리파지토리에서부터 마이바티스 DB와 관련된 빈만 컨테이너에 등록하여 테스트하는 기능을 제공하고있습니다.

해당 테스트할 레파지토리에 given 데이터를 입력하고 리파지토리의 메소드를 호출하여

반환된 값을 assertthat으로 비교하여 확인하였습니다.

